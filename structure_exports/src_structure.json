{
  "project_info": {
    "name": "src",
    "path": "C:\\Users\\User\\Desktop\\JC\\ECLECTICS\\Spring\\smart-room-allocation\\src",
    "generated_at": "2025-06-09T12:10:03.8358685",
    "total_files": 32,
    "total_size": 92095
  },
  "structure": {
    "main": {
      "java": {
        "com": {
          "smartroom": {
            "allocation": {
              "config": {
                "SecurityConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 4115,
                    "last_modified": "2025-06-09T12:10:03.6153885",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "controller": {
                "AuthController.java": {
                  "type": "file",
                  "info": {
                    "size": 3717,
                    "last_modified": "2025-06-09T12:10:03.6506551",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "BookingController.java": {
                  "type": "file",
                  "info": {
                    "size": 11611,
                    "last_modified": "2025-06-09T12:10:03.6576868",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "EquipmentController.java": {
                  "type": "file",
                  "info": {
                    "size": 2456,
                    "last_modified": "2025-06-09T12:10:03.665436",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomController.java": {
                  "type": "file",
                  "info": {
                    "size": 11660,
                    "last_modified": "2025-06-09T12:10:03.6727707",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserController.java": {
                  "type": "file",
                  "info": {
                    "size": 7585,
                    "last_modified": "2025-06-09T12:10:03.675608",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "dto": {
                "BookingResponseDTO.java": {
                  "type": "file",
                  "info": {
                    "size": 2205,
                    "last_modified": "2025-06-09T12:10:03.6855018",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomResponseDTO.java": {
                  "type": "file",
                  "info": {
                    "size": 4257,
                    "last_modified": "2025-06-09T12:10:03.6885072",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "entity": {
                "Booking.java": {
                  "type": "file",
                  "info": {
                    "size": 2941,
                    "last_modified": "2025-06-09T12:10:03.6957495",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "BookingStatus.java": {
                  "type": "file",
                  "info": {
                    "size": 135,
                    "last_modified": "2025-06-09T12:10:03.6957495",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "Equipment.java": {
                  "type": "file",
                  "info": {
                    "size": 1614,
                    "last_modified": "2025-06-09T12:10:03.70545",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "EquipmentType.java": {
                  "type": "file",
                  "info": {
                    "size": 205,
                    "last_modified": "2025-06-09T12:10:03.70545",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "Room.java": {
                  "type": "file",
                  "info": {
                    "size": 3153,
                    "last_modified": "2025-06-09T12:10:03.7158144",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomStatus.java": {
                  "type": "file",
                  "info": {
                    "size": 134,
                    "last_modified": "2025-06-09T12:10:03.7158144",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomType.java": {
                  "type": "file",
                  "info": {
                    "size": 178,
                    "last_modified": "2025-06-09T12:10:03.7203212",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "User.java": {
                  "type": "file",
                  "info": {
                    "size": 3556,
                    "last_modified": "2025-06-09T12:10:03.7253799",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserRole.java": {
                  "type": "file",
                  "info": {
                    "size": 109,
                    "last_modified": "2025-06-09T12:10:03.7253799",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "repository": {
                "BookingRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1832,
                    "last_modified": "2025-06-09T12:10:03.736255",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "EquipmentRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 611,
                    "last_modified": "2025-06-09T12:10:03.736255",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1879,
                    "last_modified": "2025-06-09T12:10:03.7454311",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 1204,
                    "last_modified": "2025-06-09T12:10:03.7512839",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "security": {
                "CustomUserDetailsService.java": {
                  "type": "file",
                  "info": {
                    "size": 2692,
                    "last_modified": "2025-06-09T12:10:03.7554334",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "JwtAuthenticationEntryPoint.java": {
                  "type": "file",
                  "info": {
                    "size": 819,
                    "last_modified": "2025-06-09T12:10:03.7554334",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "JwtAuthenticationFilter.java": {
                  "type": "file",
                  "info": {
                    "size": 3497,
                    "last_modified": "2025-06-09T12:10:03.7656087",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "JwtTokenUtil.java": {
                  "type": "file",
                  "info": {
                    "size": 3707,
                    "last_modified": "2025-06-09T12:10:03.7672208",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "service": {
                "BookingService.java": {
                  "type": "file",
                  "info": {
                    "size": 4303,
                    "last_modified": "2025-06-09T12:10:03.7752295",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "NotificationService.java": {
                  "type": "file",
                  "info": {
                    "size": 3379,
                    "last_modified": "2025-06-09T12:10:03.7752295",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RoomService.java": {
                  "type": "file",
                  "info": {
                    "size": 2815,
                    "last_modified": "2025-06-09T12:10:03.7858349",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserService.java": {
                  "type": "file",
                  "info": {
                    "size": 4106,
                    "last_modified": "2025-06-09T12:10:03.7858349",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "SmartRoomAllocationApplication.java": {
                "type": "file",
                "info": {
                  "size": 428,
                  "last_modified": "2025-06-09T12:10:03.7858349",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              }
            }
          }
        }
      },
      "resources": {
        "application.properties": {
          "type": "file",
          "info": {
            "size": 963,
            "last_modified": "2025-06-09T12:10:03.8055908",
            "mime_type": "text/x-java-properties",
            "extension": ".properties"
          }
        },
        "static": {
        },
        "templates": {
        }
      }
    },
    "test": {
      "java": {
        "com": {
          "smartroom": {
            "allocation": {
              "SmartRoomAllocationApplicationTests.java": {
                "type": "file",
                "info": {
                  "size": 229,
                  "last_modified": "2025-06-09T12:10:03.8159301",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              }
            }
          }
        }
      }
    }
  },
  "files": [
    {
      "path": "main\\java\\com\\smartroom\\allocation\\config\\SecurityConfig.java",
      "content": "package com.smartroom.allocation.config;\r\n\r\nimport com.smartroom.allocation.security.JwtAuthenticationEntryPoint;\r\nimport com.smartroom.allocation.security.JwtAuthenticationFilter;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\n\r\n@Configuration\r\n@EnableWebSecurity\r\n@EnableMethodSecurity\r\npublic class SecurityConfig {\r\n\r\n    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\r\n    private final JwtAuthenticationFilter jwtAuthenticationFilter;\r\n    private static final Logger log = LoggerFactory.getLogger(SecurityConfig.class);\r\n\r\n    public SecurityConfig(JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint,\r\n                          JwtAuthenticationFilter jwtAuthenticationFilter) {\r\n        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;\r\n        this.jwtAuthenticationFilter = jwtAuthenticationFilter;\r\n    }\r\n\r\n    @Bean\r\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\r\n        http\r\n                .cors(cors -> cors.disable()) // Disable CORS or configure as needed\r\n                .csrf(csrf -> csrf.disable()) // Disable CSRF for stateless API\r\n                .exceptionHandling(exception -> exception\r\n                        .authenticationEntryPoint(jwtAuthenticationEntryPoint)  //Handles 401 for Unauthenticated users\r\n                        //old .accessDeniedHandler\r\n//                        .accessDeniedHandler((request, response, accessDeniedException) -> {\r\n//                            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied: Insufficient permissions\");\r\n//                        }))\r\n                        .accessDeniedHandler((request, response, accessDeniedException) -> {\r\n                            log.info(\"Access Denied for {}: {}\", request.getRequestURI(), accessDeniedException.getMessage());\r\n                            response.setStatus(HttpServletResponse.SC_FORBIDDEN); // 403\r\n                            response.getWriter().write(\"Access Denied: Insufficient permissions\");\r\n                            response.setContentType(\"application/json\");\r\n                        }))\r\n                .sessionManagement(session -> session\r\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n                .authorizeHttpRequests(auth -> auth\r\n                        .requestMatchers(\"/api/auth/**\", \"/api/users/register\").permitAll()\r\n                        .requestMatchers(HttpMethod.POST, \"/api/equipment\").hasRole(\"ADMIN\")\r\n                        .anyRequest().authenticated());\r\n\r\n        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\r\n\r\n        return http.build();\r\n    }\r\n\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\r\n        return authenticationConfiguration.getAuthenticationManager();\r\n    }\r\n}",
      "info": {
        "size": 4115,
        "last_modified": "2025-06-09T12:10:03.6153885",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\controller\\AuthController.java",
      "content": "package com.smartroom.allocation.controller;\r\n\r\nimport com.smartroom.allocation.security.JwtTokenUtil;\r\nimport com.smartroom.allocation.security.CustomUserDetailsService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.BadCredentialsException;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/auth\")\r\n@CrossOrigin(origins = \"*\")\r\npublic class AuthController {\r\n\r\n    @Autowired\r\n    private AuthenticationManager authenticationManager;\r\n\r\n    @Autowired\r\n    private JwtTokenUtil jwtTokenUtil;\r\n\r\n    @Autowired\r\n    private CustomUserDetailsService userDetailsService;\r\n\r\n    /**\r\n     * Login endpoint - returns standardized response with status, message, data, and token\r\n     * @param loginRequest Contains username and password\r\n     * @return ResponseEntity with standardized JSON response\r\n     */\r\n    @PostMapping(\"/login\")\r\n    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest) {\r\n        Map<String, Object> response = new HashMap<>();\r\n\r\n        try {\r\n            // Authenticate user\r\n            authenticationManager.authenticate(\r\n                    new UsernamePasswordAuthenticationToken(\r\n                            loginRequest.getUsername(),\r\n                            loginRequest.getPassword())\r\n            );\r\n\r\n            // Load user details and generate token\r\n            UserDetails userDetails = userDetailsService.loadUserByUsername(loginRequest.getUsername());\r\n            String token = jwtTokenUtil.generateToken(userDetails);\r\n\r\n            // Populate Data field with username and role\r\n            Map<String, String> userData = new HashMap<>();\r\n            userData.put(\"username\", userDetails.getUsername());\r\n            userData.put(\"role\", userDetails.getAuthorities().iterator().next().getAuthority());\r\n\r\n            // Success response\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Login successful\");\r\n            response.put(\"Data\", userData);\r\n            response.put(\"Token\", token);\r\n\r\n            return ResponseEntity.ok(response);\r\n        } catch (BadCredentialsException e) {\r\n            // Failure response\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Invalid credentials\");\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n        } catch (Exception e) {\r\n            // Handle other unexpected exceptions\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Authentication failed: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    // Inner classes for request/response\r\n    public static class LoginRequest {\r\n        private String username;\r\n        private String password;\r\n\r\n        public String getUsername() { return username; }\r\n        public void setUsername(String username) { this.username = username; }\r\n\r\n        public String getPassword() { return password; }\r\n        public void setPassword(String password) { this.password = password; }\r\n    }\r\n}",
      "info": {
        "size": 3717,
        "last_modified": "2025-06-09T12:10:03.6506551",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\controller\\BookingController.java",
      "content": "package com.smartroom.allocation.controller;\r\n\r\nimport com.smartroom.allocation.dto.BookingResponseDTO;\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.service.BookingService;\r\nimport com.smartroom.allocation.service.RoomService;\r\nimport com.smartroom.allocation.service.UserService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\nimport java.util.stream.Collectors;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/bookings\")\r\n@CrossOrigin(origins = \"*\")\r\npublic class BookingController {\r\n\r\n    @Autowired\r\n    private BookingService bookingService;\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @Autowired\r\n    private RoomService roomService;\r\n\r\n    /**\r\n     * Create a new booking\r\n     * @param booking Booking details\r\n     * @param auth Authentication object (contains current user info)\r\n     * @return Created booking in standardized format\r\n     */\r\n    @PostMapping\r\n    public ResponseEntity<Map<String, Object>> createBooking(@RequestBody Booking booking,\r\n                                                             Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n\r\n        try {\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                response.put(\"Status\", 1);\r\n                response.put(\"Message\", \"User not found\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            booking.setUser(currentUser.get());\r\n            Booking createdBooking = bookingService.createBooking(booking);\r\n\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Booking created successfully\");\r\n            response.put(\"Data\", new BookingResponseDTO(createdBooking));\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (IllegalArgumentException e) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.badRequest().body(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Failed to create booking: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n    @PostMapping(\"/by-room-number/{roomNumber}\")\r\n    public ResponseEntity<Map<String, Object>> createBookingByRoomNumber(@PathVariable String roomNumber,\r\n                                                                         @RequestBody Booking booking,\r\n                                                                         Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"User not found\");\r\n                response.put(\"Data\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            Optional<Room> roomOpt = roomService.findByRoomNumber(roomNumber);\r\n            if (!roomOpt.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Room not found\");\r\n                response.put(\"Data\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            booking.setUser(currentUser.get());\r\n            booking.setRoom(roomOpt.get());\r\n\r\n            Booking createdBooking = bookingService.createBooking(booking);\r\n\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Booking created successfully\");\r\n            response.put(\"Data\", new BookingResponseDTO(createdBooking));\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Error: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel a booking\r\n     * @param bookingId Booking ID to cancel\r\n     * @param auth Authentication object\r\n     * @return Updated booking\r\n     */\r\n    @PutMapping(\"/{bookingId}/cancel\")\r\n    public ResponseEntity<Booking> cancelBooking(@PathVariable Long bookingId,\r\n                                                 Authentication auth) {\r\n        try {\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                return ResponseEntity.badRequest().build();\r\n            }\r\n\r\n            Booking cancelledBooking = bookingService.cancelBooking(bookingId, currentUser.get().getId());\r\n            return ResponseEntity.ok(cancelledBooking);\r\n        } catch (RuntimeException e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get current user's bookings\r\n     * @param auth Authentication object\r\n     * @return List of user's bookings in standardized format\r\n     */\r\n    @GetMapping(\"/my-bookings\")\r\n    public ResponseEntity<Map<String, Object>> getMyBookings(Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n\r\n        try {\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"User not found\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            List<Booking> bookings = bookingService.getUserBookings(currentUser.get());\r\n            List<BookingResponseDTO> bookingDTOs = bookings.stream()\r\n                    .map(BookingResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Bookings retrieved successfully\");\r\n            response.put(\"Data\", bookingDTOs);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to retrieve bookings: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Get all current bookings (Admin only)\r\n     * @return List of current bookings\r\n     */\r\n    @GetMapping(\"/current\")\r\n    public ResponseEntity<List<Booking>> getCurrentBookings() {\r\n        List<Booking> currentBookings = bookingService.getCurrentBookings();\r\n        return ResponseEntity.ok(currentBookings);\r\n    }\r\n\r\n    @GetMapping(\"/room/{roomId}/upcoming\")\r\n    public ResponseEntity<Map<String, Object>> getUpcomingBookingsForRoom(@PathVariable Long roomId, Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            // Verify user authentication\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"User not found\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            // Fetch room from RoomService\r\n            Optional<Room> roomOpt = roomService.findById(roomId);\r\n            if (!roomOpt.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Room not found with id: \" + roomId);\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            // Get upcoming bookings\r\n            List<Booking> bookings = bookingService.getUpcomingBookingsForRoom(roomOpt.get());\r\n            List<BookingResponseDTO> bookingDTOs = bookings.stream()\r\n                    .map(BookingResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Upcoming bookings retrieved successfully\");\r\n            response.put(\"Data\", bookingDTOs);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0 );\r\n            response.put(\"Message\", \"Failed to retrieve upcoming bookings: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n    @GetMapping(\"/room-number/{roomNumber}/upcoming\")\r\n    public ResponseEntity<Map<String, Object>> getUpcomingBookingsForRoomNumber(@PathVariable String roomNumber,\r\n                                                                                Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            Optional<User> currentUser = userService.findByUsername(auth.getName());\r\n            if (!currentUser.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"User not found\");\r\n                response.put(\"Data\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            Optional<Room> roomOpt = roomService.findByRoomNumber(roomNumber);\r\n            if (!roomOpt.isPresent()) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Room not found\");\r\n                response.put(\"Data\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            List<Booking> bookings = bookingService.getUpcomingBookingsForRoom(roomOpt.get());\r\n            List<BookingResponseDTO> bookingDTOs = bookings.stream()\r\n                    .map(BookingResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Upcoming bookings retrieved successfully\");\r\n            response.put(\"Data\", bookingDTOs);\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Error: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 11611,
        "last_modified": "2025-06-09T12:10:03.6576868",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\controller\\EquipmentController.java",
      "content": "package com.smartroom.allocation.controller;\r\n\r\nimport com.smartroom.allocation.entity.Equipment;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.repository.EquipmentRepository;\r\nimport com.smartroom.allocation.service.RoomService;\r\nimport jakarta.validation.Valid;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.List;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/equipment\")\r\n@CrossOrigin(origins = \"*\")\r\npublic class EquipmentController {\r\n\r\n    @Autowired\r\n    private EquipmentRepository equipmentRepository;\r\n    @Autowired\r\n    private RoomService roomService;\r\n\r\n    /**\r\n     * Get all equipment\r\n     * @return List of equipment\r\n     */\r\n    @GetMapping\r\n    public ResponseEntity<List<Equipment>> getAllEquipment() {\r\n        List<Equipment> equipment = equipmentRepository.findAll();\r\n        return ResponseEntity.ok(equipment);\r\n    }\r\n\r\n    /**\r\n     * Get all working equipment\r\n     * @return List of working equipment\r\n     */\r\n    @GetMapping(\"/working\")\r\n    public ResponseEntity<List<Equipment>> getWorkingEquipment() {\r\n        List<Equipment> workingEquipment = equipmentRepository.findByWorkingTrue();\r\n        return ResponseEntity.ok(workingEquipment);\r\n    }\r\n    @GetMapping(\"/room/{roomNumber}\")\r\n    public ResponseEntity<List<Equipment>> getEquipmentByRoom(@PathVariable String roomNumber) {\r\n        try {\r\n            Room room = roomService.findByRoomNumber(roomNumber).orElseThrow(() -> new RuntimeException(\"Room not found\"));\r\n            List<Equipment> equipment = equipmentRepository.findByRoom(room);\r\n            return ResponseEntity.ok(equipment);\r\n        } catch (RuntimeException e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create new equipment (Admin only)\r\n     * @param equipment Equipment to create\r\n     * @return Created equipment\r\n     */\r\n    @PostMapping\r\n    public ResponseEntity<Equipment> createEquipment(@Valid @RequestBody Equipment equipment) {\r\n        try {\r\n            Equipment createdEquipment = equipmentRepository.save(equipment);\r\n            return ResponseEntity.ok(createdEquipment);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 2456,
        "last_modified": "2025-06-09T12:10:03.665436",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\controller\\RoomController.java",
      "content": "package com.smartroom.allocation.controller;\r\n\r\nimport com.smartroom.allocation.dto.RoomResponseDTO;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.entity.RoomStatus;\r\nimport com.smartroom.allocation.service.RoomService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.format.annotation.DateTimeFormat;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport java.time.LocalDateTime;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.stream.Collectors;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/rooms\")\r\n@CrossOrigin(origins = \"*\")\r\npublic class RoomController {\r\n\r\n    @Autowired\r\n    private RoomService roomService;\r\n\r\n    /**\r\n     * Get all active rooms\r\n     * @return List of active rooms\r\n     */\r\n    @GetMapping\r\n    public ResponseEntity<Map<String, Object>> getAllRooms(Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 1);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            List<Room> rooms = roomService.getAllActiveRooms();\r\n            List<RoomResponseDTO> roomDTOs = rooms.stream()\r\n                    .map(RoomResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Rooms retrieved successfully\");\r\n            response.put(\"Data\", roomDTOs);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to retrieve rooms: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get room by ID\r\n     * @param id Room ID\r\n     * @return Room details\r\n     */\r\n    @GetMapping(\"/{id}\")\r\n    public ResponseEntity<Map<String, Object>> getRoomById(@PathVariable Long id, Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            Room room = roomService.findById(id)\r\n                    .orElseThrow(() -> new RuntimeException(\"Room not found with id: \" + id));\r\n            RoomResponseDTO roomDTO = new RoomResponseDTO(room);\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Room retrieved successfully\");\r\n            response.put(\"Data\", roomDTO);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (RuntimeException e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.badRequest().body(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to retrieve room: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get available rooms for a specific time period\r\n     * @param startTime Start time (format: yyyy-MM-dd'T'HH:mm:ss)\r\n     * @param endTime End time (format: yyyy-MM-dd'T'HH:mm:ss)\r\n     * @return List of available rooms\r\n     */\r\n    @GetMapping(\"/available\")\r\n    public ResponseEntity<Map<String, Object>> getAvailableRooms(\r\n            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startTime,\r\n            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endTime,\r\n            Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            if (startTime.isBefore(LocalDateTime.now())) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Start time cannot be in the past\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            if (endTime.isBefore(startTime)) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"End time must be after start time\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.badRequest().body(response);\r\n            }\r\n\r\n            List<Room> rooms = roomService.findAvailableRooms(startTime, endTime);\r\n            List<RoomResponseDTO> roomDTOs = rooms.stream()\r\n                    .map(RoomResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Available rooms retrieved successfully\");\r\n            response.put(\"Data\", roomDTOs);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to retrieve available rooms: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search rooms by minimum capacity\r\n     * @param minCapacity Minimum capacity required\r\n     * @return List of rooms with sufficient capacity\r\n     */\r\n    @GetMapping(\"/capacity/{minCapacity}\")\r\n    public ResponseEntity<Map<String, Object>> getRoomsByMinCapacity(\r\n            @PathVariable int minCapacity,\r\n            Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            List<Room> rooms = roomService.findRoomsByMinCapacity(minCapacity);\r\n            List<RoomResponseDTO> roomDTOs = rooms.stream()\r\n                    .map(RoomResponseDTO::new)\r\n                    .collect(Collectors.toList());\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Rooms with capacity >= \" + minCapacity + \" retrieved successfully\");\r\n            response.put(\"Data\", roomDTOs);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to retrieve rooms by capacity: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new room (Admin only)\r\n     * @param room Room to create\r\n     * @return Created room\r\n     */\r\n    @PostMapping\r\n    public ResponseEntity<Map<String, Object>> createRoom(@RequestBody Room room, Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            Room createdRoom = roomService.createRoom(room);\r\n            RoomResponseDTO roomDTO = new RoomResponseDTO(createdRoom);\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Room created successfully\");\r\n            response.put(\"Data\", roomDTO);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (IllegalArgumentException e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", e.getMessage()); // \"Room number already exists\"\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to create room: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n    @PutMapping(\"/{id}/status\")\r\n    @PreAuthorize(\"hasRole('ADMIN')\")\r\n    public ResponseEntity<Map<String, Object>> updateRoomStatus(@PathVariable Long id, @RequestBody Map<String, String> statusUpdate, Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            RoomStatus status = RoomStatus.valueOf(statusUpdate.get(\"status\"));\r\n            roomService.updateRoomStatus(id, status);\r\n            Room updatedRoom = roomService.findById(id).orElseThrow(() -> new RuntimeException(\"Room not found\"));\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Room status updated successfully\");\r\n            response.put(\"Data\", new RoomResponseDTO(updatedRoom));\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Failed to update room status: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 11660,
        "last_modified": "2025-06-09T12:10:03.6727707",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\controller\\UserController.java",
      "content": "package com.smartroom.allocation.controller;\r\n\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.service.UserService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/users\")\r\n@CrossOrigin(origins = \"*\")\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    /*\r\n    * Getting all the users available in Db\r\n    * Only available for Admins*/\r\n    @GetMapping\r\n    @PreAuthorize(\"hasRole('ADMIN')\")\r\n    public ResponseEntity<Map<String, Object>> getAllUsers(Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        try {\r\n            if (auth == null || auth.getName() == null) {\r\n                response.put(\"Status\", 0);\r\n                response.put(\"Message\", \"Authentication required\");\r\n                response.put(\"Data\", \"\");\r\n                response.put(\"Token\", \"\");\r\n                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);\r\n            }\r\n            List<User> users = userService.getAllUsers();\r\n            response.put(\"Status\", \"OK\");\r\n            response.put(\"Message\", \"Users retrieved successfully\");\r\n            response.put(\"Data\", users);\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.ok(response);\r\n        } catch (Exception e) {\r\n            response.put(\"Status\", \"ERROR\");\r\n            response.put(\"Message\", \"Failed to retrieve users: \" + e.getMessage());\r\n            response.put(\"Data\", \"\");\r\n            response.put(\"Token\", \"\");\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new user\r\n     * @param user User details\r\n     * @return Registered user\r\n     */\r\n    @PostMapping(\"/register\")\r\n    public ResponseEntity<User> registerUser(@RequestBody User user) {\r\n        try {\r\n            User registeredUser = userService.registerUser(user);\r\n            // Don't return password in response\r\n            registeredUser.setPassword(null);\r\n            return ResponseEntity.ok(registeredUser);\r\n        } catch (RuntimeException e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get leaderboard (for gamification)\r\n     * @return List of top users by points\r\n     */\r\n    @GetMapping(\"/leaderboard\")\r\n    public ResponseEntity<List<User>> getLeaderboard() {\r\n        List<User> leaderboard = userService.getLeaderboard();\r\n        // Remove passwords from response\r\n        leaderboard.forEach(user -> user.setPassword(null));\r\n        return ResponseEntity.ok(leaderboard);\r\n    }\r\n    // Get user by username\r\n    @GetMapping(\"/username/{username}\")\r\n    public ResponseEntity<Map<String, Object>> getUserByUsername(@PathVariable String username) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        Optional<User> user = userService.findByUsername(username);\r\n        if (user.isPresent()) {\r\n            user.get().setPassword(null);\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"User retrieved successfully\");\r\n            response.put(\"Data\", user.get());\r\n            return ResponseEntity.ok(response);\r\n        } else {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"User not found\");\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);\r\n        }\r\n    }\r\n    // Admin: Update user by ID\r\n    @PutMapping(\"/{id}\")\r\n    @PreAuthorize(\"hasRole('ADMIN')\")\r\n    public ResponseEntity<Map<String, Object>> updateUserById(@PathVariable Long id, @RequestBody User userUpdate) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        Optional<User> updated = userService.updateUserById(id, userUpdate);\r\n        if (updated.isPresent()) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"User updated successfully\");\r\n            response.put(\"Data\", updated.get());\r\n            return ResponseEntity.ok(response);\r\n        } else {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"User not found\");\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);\r\n        }\r\n    }\r\n\r\n    // User: Update own profile\r\n    @PutMapping(\"/me\")\r\n    public ResponseEntity<Map<String, Object>> updateOwnProfile(Authentication auth, @RequestBody User userUpdate) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        Optional<User> current = userService.findByUsername(auth.getName());\r\n        if (!current.isPresent()) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"User not found\");\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\r\n        }\r\n        Optional<User> updated = userService.updateUserById(current.get().getId(), userUpdate);\r\n        if (updated.isPresent()) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Profile updated successfully\");\r\n            response.put(\"Data\", updated.get());\r\n            return ResponseEntity.ok(response);\r\n        } else {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Update failed\");\r\n            response.put(\"Data\", \"\");\r\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\r\n        }\r\n    }\r\n\r\n    // Admin: Delete user by ID\r\n    @DeleteMapping(\"/{id}\")\r\n    @PreAuthorize(\"hasRole('ADMIN')\")\r\n    public ResponseEntity<Map<String, Object>> deleteUserById(@PathVariable Long id) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        boolean deleted = userService.deleteUserById(id);\r\n        if (deleted) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"User deleted successfully\");\r\n            return ResponseEntity.ok(response);\r\n        } else {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"User not found\");\r\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);\r\n        }\r\n    }\r\n\r\n    // User: Delete own account\r\n    @DeleteMapping(\"/me\")\r\n    public ResponseEntity<Map<String, Object>> deleteOwnAccount(Authentication auth) {\r\n        Map<String, Object> response = new HashMap<>();\r\n        Optional<User> current = userService.findByUsername(auth.getName());\r\n        if (!current.isPresent()) {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"User not found\");\r\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\r\n        }\r\n        boolean deleted = userService.deleteUserById(current.get().getId());\r\n        if (deleted) {\r\n            response.put(\"Status\", 1);\r\n            response.put(\"Message\", \"Account deleted successfully\");\r\n            return ResponseEntity.ok(response);\r\n        } else {\r\n            response.put(\"Status\", 0);\r\n            response.put(\"Message\", \"Deletion failed\");\r\n            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 7585,
        "last_modified": "2025-06-09T12:10:03.675608",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\dto\\BookingResponseDTO.java",
      "content": "package com.smartroom.allocation.dto;\r\n\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport com.smartroom.allocation.entity.BookingStatus;\r\nimport java.time.LocalDateTime;\r\n\r\npublic class BookingResponseDTO {\r\n    private Long id;\r\n    private Long roomId;\r\n    private String lecturerName; // Added field for lecturer's name\r\n    private LocalDateTime startTime;\r\n    private LocalDateTime endTime;\r\n    private BookingStatus status;\r\n    private LocalDateTime createdAt;\r\n    private LocalDateTime updatedAt;\r\n\r\n    // Constructor\r\n    public BookingResponseDTO(Booking booking) {\r\n        this.id = booking.getId();\r\n        this.roomId = booking.getRoom() != null ? booking.getRoom().getId() : null;\r\n        this.lecturerName = booking.getUser() != null ? booking.getUser().getFullName() : null; // Populate lecturer's name\r\n        this.startTime = booking.getStartTime();\r\n        this.endTime = booking.getEndTime();\r\n        this.status = booking.getStatus();\r\n        this.createdAt = booking.getCreatedAt();\r\n        this.updatedAt = booking.getUpdatedAt();\r\n    }\r\n\r\n    // Getters and setters\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public Long getRoomId() { return roomId; }\r\n    public void setRoomId(Long roomId) { this.roomId = roomId; }\r\n\r\n    public String getLecturerName() { return lecturerName; }\r\n    public void setLecturerName(String lecturerName) { this.lecturerName = lecturerName; }\r\n\r\n    public LocalDateTime getStartTime() { return startTime; }\r\n    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }\r\n\r\n    public LocalDateTime getEndTime() { return endTime; }\r\n    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }\r\n\r\n    public BookingStatus getStatus() { return status; }\r\n    public void setStatus(BookingStatus status) { this.status = status; }\r\n\r\n    public LocalDateTime getCreatedAt() { return createdAt; }\r\n    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }\r\n\r\n    public LocalDateTime getUpdatedAt() { return updatedAt; }\r\n    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }\r\n}",
      "info": {
        "size": 2205,
        "last_modified": "2025-06-09T12:10:03.6855018",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\dto\\RoomResponseDTO.java",
      "content": "package com.smartroom.allocation.dto;\r\n\r\nimport com.smartroom.allocation.entity.Equipment;\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport com.smartroom.allocation.entity.BookingStatus;\r\nimport com.smartroom.allocation.entity.RoomStatus;\r\nimport com.smartroom.allocation.entity.RoomType;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class RoomResponseDTO {\r\n    private Long id;\r\n    private String roomNumber;\r\n    private String name;\r\n    private int capacity;\r\n    private String building;\r\n    private String floor;\r\n    private String location;\r\n    private RoomType roomType;\r\n    private RoomStatus status;\r\n    private boolean isActive;\r\n    private List<EquipmentSummaryDTO> equipment;\r\n    private List<BookingSummaryDTO> bookings;\r\n\r\n    // Inner class to summarize equipment\r\n    public static class EquipmentSummaryDTO {\r\n        private Long id;\r\n        private String name;\r\n\r\n        public EquipmentSummaryDTO(Equipment equipment) {\r\n            this.id = equipment.getId();\r\n            this.name = equipment.getName();\r\n        }\r\n\r\n        public Long getId() { return id; }\r\n        public String getName() { return name; }\r\n    }\r\n\r\n    // Inner class to summarize bookings\r\n    public static class BookingSummaryDTO {\r\n        private Long id;\r\n        private String purpose;\r\n        private BookingStatus status;\r\n\r\n        public BookingSummaryDTO(Booking booking) {\r\n            this.id = booking.getId();\r\n            this.purpose = booking.getPurpose();\r\n            this.status = booking.getStatus();\r\n        }\r\n\r\n        public Long getId() { return id; }\r\n        public String getPurpose() { return purpose; }\r\n        public BookingStatus getStatus() { return status; }\r\n    }\r\n\r\n    // Constructor\r\n    public RoomResponseDTO(com.smartroom.allocation.entity.Room room) {\r\n        this.id = room.getId();\r\n        this.roomNumber = room.getRoomNumber();\r\n        this.name = room.getName();\r\n        this.capacity = room.getCapacity();\r\n        this.building = room.getBuilding();\r\n        this.floor = room.getFloor();\r\n        this.location = room.getLocation();\r\n        this.roomType = room.getRoomType();\r\n        this.status = room.getStatus();\r\n        this.isActive = room.isActive();\r\n        this.equipment = room.getEquipment() != null ? room.getEquipment().stream()\r\n                .map(EquipmentSummaryDTO::new)\r\n                .collect(Collectors.toList()) : null;\r\n        this.bookings = room.getBookings() != null ? room.getBookings().stream()\r\n                .map(BookingSummaryDTO::new)\r\n                .collect(Collectors.toList()) : null;\r\n    }\r\n\r\n    // Getters and setters\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public String getRoomNumber() { return roomNumber; }\r\n    public void setRoomNumber(String roomNumber) { this.roomNumber = roomNumber; }\r\n\r\n    public String getName() { return name; }\r\n    public void setName(String name) { this.name = name; }\r\n\r\n    public int getCapacity() { return capacity; }\r\n    public void setCapacity(int capacity) { this.capacity = capacity; }\r\n\r\n    public String getBuilding() { return building; }\r\n    public void setBuilding(String building) { this.building = building; }\r\n\r\n    public String getFloor() { return floor; }\r\n    public void setFloor(String floor) { this.floor = floor; }\r\n\r\n    public String getLocation() { return location; }\r\n    public void setLocation(String location) { this.location = location; }\r\n\r\n    public RoomType getRoomType() { return roomType; }\r\n    public void setRoomType(RoomType roomType) { this.roomType = roomType; }\r\n\r\n    public RoomStatus getStatus() { return status; }\r\n    public void setStatus(RoomStatus status) { this.status = status; }\r\n\r\n    public boolean isActive() { return isActive; }\r\n    public void setActive(boolean isActive) { this.isActive = isActive; }\r\n\r\n    public List<EquipmentSummaryDTO> getEquipment() { return equipment; }\r\n    public void setEquipment(List<EquipmentSummaryDTO> equipment) { this.equipment = equipment; }\r\n\r\n    public List<BookingSummaryDTO> getBookings() { return bookings; }\r\n    public void setBookings(List<BookingSummaryDTO> bookings) { this.bookings = bookings; }\r\n}",
      "info": {
        "size": 4257,
        "last_modified": "2025-06-09T12:10:03.6885072",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\Booking.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonBackReference;\r\nimport jakarta.persistence.*;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport jakarta.validation.constraints.NotNull;\r\nimport java.time.LocalDateTime;\r\n\r\n@Entity\r\n@Table(name = \"bookings\")\r\npublic class Booking {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @JsonBackReference(\"user-bookings\")\r\n    @ManyToOne\r\n    @JoinColumn(name = \"user_id\", nullable = false)\r\n    private User user;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"room_id\", nullable = false)\r\n    @JsonBackReference(\"room-bookings\")\r\n    private Room room;\r\n\r\n    @NotNull(message = \"Start time is required\")\r\n    private LocalDateTime startTime;\r\n\r\n    @NotNull(message = \"End time is required\")\r\n    private LocalDateTime endTime;\r\n\r\n    @NotBlank(message = \"Purpose is required\")\r\n    private String purpose;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private BookingStatus status = BookingStatus.CONFIRMED;\r\n\r\n    private LocalDateTime createdAt = LocalDateTime.now();\r\n    private LocalDateTime updatedAt = LocalDateTime.now();\r\n\r\n    private String notes;\r\n    private boolean recurring = false;\r\n\r\n    public Booking() {}\r\n\r\n    public Booking(User user, Room room, LocalDateTime startTime, LocalDateTime endTime, String purpose) {\r\n        this.user = user;\r\n        this.room = room;\r\n        this.startTime = startTime;\r\n        this.endTime = endTime;\r\n        this.purpose = purpose;\r\n    }\r\n\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public User getUser() { return user; }\r\n    public void setUser(User user) { this.user = user; }\r\n\r\n    public Room getRoom() { return room; }\r\n    public void setRoom(Room room) { this.room = room; }\r\n\r\n    public LocalDateTime getStartTime() { return startTime; }\r\n    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }\r\n\r\n    public LocalDateTime getEndTime() { return endTime; }\r\n    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }\r\n\r\n    public String getPurpose() { return purpose; }\r\n    public void setPurpose(String purpose) { this.purpose = purpose; }\r\n\r\n    public BookingStatus getStatus() { return status; }\r\n    public void setStatus(BookingStatus status) { this.status = status; }\r\n\r\n    public LocalDateTime getCreatedAt() { return createdAt; }\r\n    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }\r\n\r\n    public LocalDateTime getUpdatedAt() { return updatedAt; }\r\n    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }\r\n\r\n    public String getNotes() { return notes; }\r\n    public void setNotes(String notes) { this.notes = notes; }\r\n\r\n    public boolean isRecurring() { return recurring; }\r\n    public void setRecurring(boolean recurring) { this.recurring = recurring; }\r\n}",
      "info": {
        "size": 2941,
        "last_modified": "2025-06-09T12:10:03.6957495",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\BookingStatus.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\npublic enum BookingStatus {\r\n    CONFIRMED,\r\n    CANCELLED,\r\n    COMPLETED,\r\n    NO_SHOW\r\n}",
      "info": {
        "size": 135,
        "last_modified": "2025-06-09T12:10:03.6957495",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\Equipment.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonBackReference;\r\nimport jakarta.persistence.*;\r\nimport jakarta.validation.constraints.NotBlank;\r\n\r\n@Entity\r\n@Table(name = \"equipment\")\r\npublic class Equipment {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @NotBlank(message = \"Equipment name is required\")\r\n    private String name;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private EquipmentType type;\r\n\r\n    private String description;\r\n    private boolean working = true;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"room_id\")\r\n    @JsonBackReference\r\n    private Room room;\r\n\r\n    public Equipment() {}\r\n\r\n    public Equipment(String name, EquipmentType type, String description, Room room) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.description = description;\r\n        this.room = room;\r\n    }\r\n\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public String getName() { return name; }\r\n    public void setName(String name) { this.name = name; }\r\n\r\n    public EquipmentType getType() { return type; }\r\n    public void setType(EquipmentType type) { this.type = type; }\r\n\r\n    public String getDescription() { return description; }\r\n    public void setDescription(String description) { this.description = description; }\r\n\r\n    public boolean isWorking() { return working; }\r\n    public void setWorking(boolean working) { this.working = working; }\r\n\r\n    public Room getRoom() { return room; }\r\n    public void setRoom(Room room) { this.room = room; }\r\n}",
      "info": {
        "size": 1614,
        "last_modified": "2025-06-09T12:10:03.70545",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\EquipmentType.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\npublic enum EquipmentType {\r\n    PROJECTOR,\r\n    PA_SYSTEM,\r\n    WHITEBOARD,\r\n    COMPUTER,\r\n    AIR_CONDITIONING,\r\n    MICROPHONE,\r\n    SCREEN,\r\n    SPEAKERS\r\n}",
      "info": {
        "size": 205,
        "last_modified": "2025-06-09T12:10:03.70545",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\Room.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonManagedReference;\r\nimport jakarta.persistence.*;\r\nimport jakarta.validation.constraints.Min;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport java.util.List;\r\n\r\n@Entity\r\n@Table(name = \"rooms\")\r\npublic class Room {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @NotBlank(message = \"Room number is required\")\r\n    @Column(unique = true)\r\n    private String roomNumber;\r\n\r\n    @NotBlank(message = \"Room name is required\")\r\n    private String name;\r\n\r\n    @Min(value = 1, message = \"Capacity must be at least 1\")\r\n    private int capacity;\r\n\r\n    private String building;\r\n    private String floor;\r\n    private String location;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private RoomType roomType;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private RoomStatus status = RoomStatus.AVAILABLE;\r\n\r\n    private boolean active = true;\r\n\r\n    @OneToMany(mappedBy = \"room\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\r\n    @JsonManagedReference\r\n    private List<Equipment> equipment;\r\n\r\n    @OneToMany(mappedBy = \"room\", cascade = CascadeType.ALL)\r\n    @JsonManagedReference(\"room-bookings\")\r\n    private List<Booking> bookings;\r\n\r\n    public Room() {}\r\n\r\n    public Room(String roomNumber, String name, int capacity, String building, String floor, RoomType roomType) {\r\n        this.roomNumber = roomNumber;\r\n        this.name = name;\r\n        this.capacity = capacity;\r\n        this.building = building;\r\n        this.floor = floor;\r\n        this.roomType = roomType;\r\n    }\r\n\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public String getRoomNumber() { return roomNumber; }\r\n    public void setRoomNumber(String roomNumber) { this.roomNumber = roomNumber; }\r\n\r\n    public String getName() { return name; }\r\n    public void setName(String name) { this.name = name; }\r\n\r\n    public int getCapacity() { return capacity; }\r\n    public void setCapacity(int capacity) { this.capacity = capacity; }\r\n\r\n    public String getBuilding() { return building; }\r\n    public void setBuilding(String building) { this.building = building; }\r\n\r\n    public String getFloor() { return floor; }\r\n    public void setFloor(String floor) { this.floor = floor; }\r\n\r\n    public String getLocation() { return location; }\r\n    public void setLocation(String location) { this.location = location; }\r\n\r\n    public RoomType getRoomType() { return roomType; }\r\n    public void setRoomType(RoomType roomType) { this.roomType = roomType; }\r\n\r\n    public RoomStatus getStatus() { return status; }\r\n    public void setStatus(RoomStatus status) { this.status = status; }\r\n\r\n    public boolean isActive() { return active; }\r\n    public void setActive(boolean active) { this.active = active; }\r\n\r\n    public List<Equipment> getEquipment() { return equipment; }\r\n    public void setEquipment(List<Equipment> equipment) { this.equipment = equipment; }\r\n\r\n    public List<Booking> getBookings() { return bookings; }\r\n    public void setBookings(List<Booking> bookings) { this.bookings = bookings; }\r\n}",
      "info": {
        "size": 3153,
        "last_modified": "2025-06-09T12:10:03.7158144",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\RoomStatus.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\npublic enum RoomStatus {\r\n    AVAILABLE,\r\n    OCCUPIED,\r\n    MAINTENANCE,\r\n    RESERVED\r\n}",
      "info": {
        "size": 134,
        "last_modified": "2025-06-09T12:10:03.7158144",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\RoomType.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\npublic enum RoomType {\r\n    LECTURE_HALL,\r\n    CLASSROOM,\r\n    LABORATORY,\r\n    CONFERENCE_ROOM,\r\n    COMPUTER_LAB,\r\n    AUDITORIUM\r\n}",
      "info": {
        "size": 178,
        "last_modified": "2025-06-09T12:10:03.7203212",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\User.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonManagedReference;\r\nimport jakarta.persistence.*;\r\nimport jakarta.validation.constraints.Email;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\n\r\n@Entity\r\n@Table(name = \"users\")\r\npublic class User {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @NotBlank(message = \"Username is required\")\r\n    @Column(unique = true)\r\n    private String username;\r\n\r\n    @NotBlank(message = \"Email is required\")\r\n    @Email(message = \"Email should be valid\")\r\n    @Column(unique = true)\r\n    private String email;\r\n\r\n    @NotBlank(message = \"Password is required\")\r\n    private String password;\r\n\r\n    @NotBlank(message = \"Full name is required\")\r\n    private String fullName;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private UserRole role; // ADMIN, LECTURER, STUDENT\r\n\r\n    private String department;\r\n    private boolean active = true;\r\n    private LocalDateTime createdAt = LocalDateTime.now();\r\n\r\n    // Gamification fields\r\n    private int usageStreak = 0; // Days of consecutive usage\r\n    private int totalBookings = 0;\r\n    private int points = 0;\r\n\r\n    // One-to-many relationship with bookings\r\n    @JsonManagedReference(\"user-bookings\") // Manage serialization of bookings\r\n    @OneToMany(mappedBy = \"user\", cascade = CascadeType.ALL)\r\n    private List<Booking> bookings;\r\n\r\n    // Constructors\r\n    public User() {}\r\n\r\n    public User(String username, String email, String password, String fullName, UserRole role, String department) {\r\n        this.username = username;\r\n        this.email = email;\r\n        this.password = password;\r\n        this.fullName = fullName;\r\n        this.role = role;\r\n        this.department = department;\r\n    }\r\n\r\n    // Getters and Setters\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n\r\n    public String getUsername() { return username; }\r\n    public void setUsername(String username) { this.username = username; }\r\n\r\n    public String getEmail() { return email; }\r\n    public void setEmail(String email) { this.email = email; }\r\n\r\n    public String getPassword() { return password; }\r\n    public void setPassword(String password) { this.password = password; }\r\n\r\n    public String getFullName() { return fullName; }\r\n    public void setFullName(String fullName) { this.fullName = fullName; }\r\n\r\n    public UserRole getRole() { return role; }\r\n    public void setRole(UserRole role) { this.role = role; }\r\n\r\n    public String getDepartment() { return department; }\r\n    public void setDepartment(String department) { this.department = department; }\r\n\r\n    public boolean isActive() { return active; }\r\n    public void setActive(boolean active) { this.active = active; }\r\n\r\n    public LocalDateTime getCreatedAt() { return createdAt; }\r\n    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }\r\n\r\n    public int getUsageStreak() { return usageStreak; }\r\n    public void setUsageStreak(int usageStreak) { this.usageStreak = usageStreak; }\r\n\r\n    public int getTotalBookings() { return totalBookings; }\r\n    public void setTotalBookings(int totalBookings) { this.totalBookings = totalBookings; }\r\n\r\n    public int getPoints() { return points; }\r\n    public void setPoints(int points) { this.points = points; }\r\n\r\n    public List<Booking> getBookings() { return bookings; }\r\n    public void setBookings(List<Booking> bookings) { this.bookings = bookings; }\r\n}",
      "info": {
        "size": 3556,
        "last_modified": "2025-06-09T12:10:03.7253799",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\entity\\UserRole.java",
      "content": "package com.smartroom.allocation.entity;\r\n\r\npublic enum UserRole {\r\n    ADMIN,\r\n    LECTURER,\r\n    STUDENT\r\n}",
      "info": {
        "size": 109,
        "last_modified": "2025-06-09T12:10:03.7253799",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\repository\\BookingRepository.java",
      "content": "package com.smartroom.allocation.repository;\r\n\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.entity.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\n\r\n@Repository\r\npublic interface BookingRepository extends JpaRepository<Booking, Long> {\r\n\r\n    // Count conflicting bookings for a room within a time range\r\n    @Query(\"SELECT COUNT(b) FROM Booking b WHERE b.room = :room \" +\r\n            \"AND b.status = 'CONFIRMED' \" +\r\n            \"AND (b.startTime < :endTime AND b.endTime > :startTime)\")\r\n    Long countConflictingBookings(@Param(\"room\") Room room,\r\n                                  @Param(\"startTime\") LocalDateTime startTime,\r\n                                  @Param(\"endTime\") LocalDateTime endTime);\r\n\r\n    // Find bookings by user\r\n    List<Booking> findByUser(User user);\r\n\r\n    //Count bookings by user\r\n    int countByUser(User user);\r\n\r\n    // Find current bookings (ongoing at the given time)\r\n    @Query(\"SELECT b FROM Booking b WHERE b.status = 'CONFIRMED' \" +\r\n            \"AND b.startTime <= :currentTime AND b.endTime >= :currentTime\")\r\n    List<Booking> findCurrentBookings(@Param(\"currentTime\") LocalDateTime currentTime);\r\n\r\n    // Find upcoming bookings for a specific room\r\n    @Query(\"SELECT b FROM Booking b WHERE b.room = :room \" +\r\n            \"AND b.status = 'CONFIRMED' AND b.startTime > :currentTime\")\r\n    List<Booking> findUpcomingBookingsForRoom(@Param(\"room\") Room room,\r\n                                              @Param(\"currentTime\") LocalDateTime currentTime);\r\n}",
      "info": {
        "size": 1832,
        "last_modified": "2025-06-09T12:10:03.736255",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\repository\\EquipmentRepository.java",
      "content": "package com.smartroom.allocation.repository;\r\n\r\nimport com.smartroom.allocation.entity.Equipment;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\nimport java.util.List;\r\n\r\n@Repository\r\npublic interface EquipmentRepository extends JpaRepository<Equipment, Long> {\r\n\r\n    // Find equipment by name\r\n    List<Equipment> findByName(String name);\r\n\r\n    // Find equipment by room\r\n    List<Equipment> findByRoom(Room room);\r\n\r\n    // Find available equipment\r\n    List<Equipment> findByWorkingTrue();\r\n}",
      "info": {
        "size": 611,
        "last_modified": "2025-06-09T12:10:03.736255",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\repository\\RoomRepository.java",
      "content": "package com.smartroom.allocation.repository;\r\n\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.entity.RoomStatus;\r\nimport com.smartroom.allocation.entity.RoomType;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic interface RoomRepository extends JpaRepository<Room, Long> {\r\n\r\n    // Find room by room number\r\n    Optional<Room> findByRoomNumber(String roomNumber);\r\n\r\n    // *** Add this method to check for existence of room number ***\r\n    boolean existsByRoomNumber(String roomNumber);\r\n\r\n\r\n\r\n    // Find all active rooms\r\n    List<Room> findByActiveTrue();\r\n\r\n    // Find rooms by status\r\n    List<Room> findByStatus(RoomStatus status);\r\n\r\n    // Find rooms by type\r\n    List<Room> findByRoomType(RoomType roomType);\r\n\r\n    // Find rooms by building\r\n    List<Room> findByBuilding(String building);\r\n\r\n    // Find rooms with minimum capacity\r\n    List<Room> findByCapacityGreaterThanEqual(int minCapacity);\r\n\r\n    // Find available rooms at a specific time (complex query)\r\n    @Query(\"SELECT r FROM Room r WHERE r.active = true AND r.status = 'AVAILABLE' \" +\r\n            \"AND r.id NOT IN (\" +\r\n            \"SELECT b.room.id FROM Booking b WHERE b.status = 'CONFIRMED' \" +\r\n            \"AND ((b.startTime <= :startTime AND b.endTime > :startTime) \" +\r\n            \"OR (b.startTime < :endTime AND b.endTime >= :endTime) \" +\r\n            \"OR (b.startTime >= :startTime AND b.endTime <= :endTime)))\")\r\n    List<Room> findAvailableRooms(@Param(\"startTime\") LocalDateTime startTime,\r\n                                  @Param(\"endTime\") LocalDateTime endTime);\r\n}",
      "info": {
        "size": 1879,
        "last_modified": "2025-06-09T12:10:03.7454311",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\repository\\UserRepository.java",
      "content": "package com.smartroom.allocation.repository;\r\n\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.entity.UserRole;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.stereotype.Repository;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic interface UserRepository extends JpaRepository<User, Long> {\r\n\r\n    // Find user by username (for authentication)\r\n    Optional<User> findByUsername(String username);\r\n\r\n    // Find user by email\r\n    Optional<User> findByEmail(String email);\r\n\r\n    // Find all active users\r\n    List<User> findByActiveTrue();\r\n\r\n    // Find users by role\r\n    List<User> findByRole(UserRole role);\r\n\r\n    // Find users by department\r\n    List<User> findByDepartment(String department);\r\n\r\n    // Check if username exists\r\n    boolean existsByUsername(String username);\r\n\r\n    // Check if email exists\r\n    boolean existsByEmail(String email);\r\n\r\n    // Find top users by points (for gamification leaderboard)\r\n    @Query(\"SELECT u FROM User u WHERE u.active = true ORDER BY u.points DESC\")\r\n    List<User> findTopUsersByPoints();\r\n}",
      "info": {
        "size": 1204,
        "last_modified": "2025-06-09T12:10:03.7512839",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\security\\CustomUserDetailsService.java",
      "content": "package com.smartroom.allocation.security;\r\n\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.repository.UserRepository;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n\r\n\r\n@Service\r\npublic class CustomUserDetailsService implements UserDetailsService {\r\n    private static final Logger logger = LoggerFactory.getLogger(CustomUserDetailsService.class);\r\n    @Autowired\r\n    private UserRepository userRepository;\r\n\r\n    /**\r\n     * Load user by username for Spring Security authentication\r\n     * @param username Username to load\r\n     * @return UserDetails object\r\n     */\r\n    @Override\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        logger.info(\"CustomUserDetailsService: Loading user by username: \" + username); // ADD THIS\r\n        User user = userRepository.findByUsername(username)\r\n//                .orElseThrow(() -> new UsernameNotFoundException(\"User not found: \" + username));\r\n                .orElseThrow(() -> {\r\n                    logger.warn(\"CustomUserDetailsService: User not found with username: \" + username); // ADD THIS\r\n                    return new UsernameNotFoundException(\"User not found: \" + username);\r\n                });\r\n        logger.info(\"CustomUserDetailsService: User found: \" + user.getUsername() + \", Role: \" + user.getRole() + \", Active: \" + user.isActive()); // ADD THIS\r\n\r\n\r\n        // Convert user role to Spring Security authorities\r\n        List<GrantedAuthority> authorities = new ArrayList<>();\r\n        authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + user.getRole().toString()));\r\n        logger.info(\"CustomUserDetailsService: Authorities created: \" + authorities); // ADD THIS\r\n\r\n\r\n        return org.springframework.security.core.userdetails.User.builder()\r\n                .username(user.getUsername())\r\n                .password(user.getPassword())\r\n                .authorities(authorities)\r\n                .accountExpired(false)\r\n                .accountLocked(!user.isActive())\r\n                .credentialsExpired(false)\r\n                .disabled(!user.isActive())\r\n                .build();\r\n    }\r\n}",
      "info": {
        "size": 2692,
        "last_modified": "2025-06-09T12:10:03.7554334",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\security\\JwtAuthenticationEntryPoint.java",
      "content": "package com.smartroom.allocation.security;\r\n\r\nimport org.springframework.security.core.AuthenticationException;\r\nimport org.springframework.security.web.AuthenticationEntryPoint;\r\nimport org.springframework.stereotype.Component;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n@Component\r\npublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {\r\n\r\n    /**\r\n     * Handle unauthorized access attempts\r\n     */\r\n    @Override\r\n    public void commence(HttpServletRequest request,\r\n                         HttpServletResponse response,\r\n                         AuthenticationException authException) throws IOException {\r\n\r\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\r\n    }\r\n}",
      "info": {
        "size": 819,
        "last_modified": "2025-06-09T12:10:03.7554334",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\security\\JwtAuthenticationFilter.java",
      "content": "package com.smartroom.allocation.security;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\nimport jakarta.servlet.FilterChain;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n@Component\r\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\r\n\r\n    @Autowired\r\n    private CustomUserDetailsService userDetailsService;\r\n\r\n    @Autowired\r\n    private JwtTokenUtil jwtTokenUtil;\r\n\r\n    /**\r\n     * Filter incoming requests to check for JWT tokens\r\n     */\r\n    @Override\r\n    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\r\n        String path = request.getRequestURI();\r\n        return path.startsWith(\"/api/auth/\") || path.equals(\"/api/users/register\");\r\n    }\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest request,\r\n                                    HttpServletResponse response,\r\n                                    FilterChain chain) throws ServletException, IOException {\r\n\r\n        final String requestTokenHeader = request.getHeader(\"Authorization\");\r\n        logger.info(\"Request URI: \" + request.getRequestURI()); // ADDED THIS FOR MORE LOGGING TO DEBUG\r\n        logger.info(\"Authorization Header: \" + requestTokenHeader); // ADDED THIS FOR MORE LOGGING TO DEBUG\r\n        String username = null;\r\n        String jwtToken = null;\r\n\r\n        // JWT Token is in the form \"Bearer token\"\r\n        if (requestTokenHeader != null && requestTokenHeader.startsWith(\"Bearer \")) {\r\n            jwtToken = requestTokenHeader.substring(7);\r\n            try {\r\n                username = jwtTokenUtil.getUsernameFromToken(jwtToken);\r\n            } catch (Exception e) {\r\n                logger.error(\"Unable to get JWT Token or JWT Token has expired\");\r\n            }\r\n        }\r\n\r\n        // Validate token and set authentication\r\n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\r\n            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\r\n            logger.info(\"Authorities for user \" + username + \": \" + userDetails.getAuthorities()); // ADD THIS\r\n            if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {\r\n                UsernamePasswordAuthenticationToken authToken =\r\n                        new UsernamePasswordAuthenticationToken(\r\n                                userDetails, null, userDetails.getAuthorities());\r\n                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n                SecurityContextHolder.getContext().setAuthentication(authToken);\r\n                logger.info(\"Successfully set authentication for user: \" + userDetails.getUsername()); // ADD THIS LINE\r\n            }else {\r\n                logger.warn(\"Token validation failed for user: \" + userDetails.getUsername());} // ADD THIS LINE (if validateToken was false)\r\n        }\r\n\r\n        chain.doFilter(request, response);\r\n    }\r\n}",
      "info": {
        "size": 3497,
        "last_modified": "2025-06-09T12:10:03.7656087",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\security\\JwtTokenUtil.java",
      "content": "package com.smartroom.allocation.security;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.stereotype.Component;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\n\r\n@Component\r\npublic class JwtTokenUtil {\r\n    // This line gets a logger specific to JwtAuthenticationFilter\r\n    private static final Logger logger = LoggerFactory.getLogger(JwtTokenUtil.class);\r\n\r\n    @Value(\"${jwt.secret}\")\r\n    private String secret;\r\n\r\n    @Value(\"${jwt.expiration}\")\r\n    private Long expiration;\r\n\r\n    /**\r\n     * Extract username from JWT token\r\n     */\r\n    public String getUsernameFromToken(String token) {\r\n\r\n        try { // ADD THIS TRY-CATCH\r\n            return getClaimFromToken(token, Claims::getSubject); // [cite: 235]\r\n        } catch (Exception e) {\r\n            logger.error(\"Error getting username from token: \" + token, e); // ADD THIS\r\n            throw e; // Re-throw to maintain behavior\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract expiration date from JWT token\r\n     */\r\n    public Date getExpirationDateFromToken(String token) {\r\n        return getClaimFromToken(token, Claims::getExpiration);\r\n    }\r\n\r\n    /**\r\n     * Extract specific claim from JWT token\r\n     */\r\n    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\r\n        final Claims claims = getAllClaimsFromToken(token);\r\n        return claimsResolver.apply(claims);\r\n    }\r\n\r\n    /**\r\n     * Get all claims from JWT token\r\n     */\r\n    private Claims getAllClaimsFromToken(String token) {\r\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\r\n    }\r\n\r\n    /**\r\n     * Check if JWT token is expired\r\n     */\r\n    private Boolean isTokenExpired(String token) {\r\n        final Date expiration = getExpirationDateFromToken(token);\r\n        return expiration.before(new Date());\r\n    }\r\n\r\n    /**\r\n     * Generate JWT token for user\r\n     */\r\n    public String generateToken(UserDetails userDetails) {\r\n        Map<String, Object> claims = new HashMap<>();\r\n        return createToken(claims, userDetails.getUsername());\r\n    }\r\n\r\n    /**\r\n     * Create JWT token with claims and subject\r\n     */\r\n    private String createToken(Map<String, Object> claims, String subject) {\r\n        return Jwts.builder()\r\n                .setClaims(claims)\r\n                .setSubject(subject)\r\n                .setIssuedAt(new Date(System.currentTimeMillis()))\r\n                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))\r\n                .signWith(SignatureAlgorithm.HS512, secret)\r\n                .compact();\r\n    }\r\n\r\n    /**\r\n     * Validate JWT token\r\n     */\r\n    public Boolean validateToken(String token, UserDetails userDetails) {\r\n\r\n        try { // ADD THIS TRY-CATCH\r\n            final String username = getUsernameFromToken(token); // [cite: 243]\r\n            boolean isValid = (username.equals(userDetails.getUsername()) && !isTokenExpired(token)); // [cite: 244]\r\n            logger.info(\"Validating token for user: \" + username + \". Is valid? \" + isValid); // ADD THIS\r\n            if (isTokenExpired(token)) {\r\n                logger.warn(\"Token for user \" + username + \" is expired.\"); // ADD THIS\r\n            }\r\n            return isValid;\r\n        } catch (Exception e) {\r\n            logger.error(\"Error validating token: \" + token, e); // ADD THIS\r\n            return false;\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 3707,
        "last_modified": "2025-06-09T12:10:03.7672208",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\service\\BookingService.java",
      "content": "package com.smartroom.allocation.service;\r\n\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport com.smartroom.allocation.entity.BookingStatus;\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.repository.BookingRepository;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Service\r\npublic class BookingService {\r\n\r\n    @Autowired\r\n    private BookingRepository bookingRepository;\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @Autowired\r\n    private NotificationService notificationService;\r\n\r\n    /**\r\n     * Create a new booking\r\n     * @param booking Booking to create\r\n     * @return Created booking\r\n     * @throws IllegalArgumentException if there's a conflict or invalid booking details\r\n     */\r\n    public Booking createBooking(Booking booking) {\r\n        // Check for booking conflicts\r\n        Long conflicts = bookingRepository.countConflictingBookings(\r\n                booking.getRoom(),\r\n                booking.getStartTime(),\r\n                booking.getEndTime()\r\n        );\r\n\r\n        if (conflicts > 0) {\r\n            throw new IllegalArgumentException(\"Room is already booked for the specified time\");\r\n        }\r\n\r\n        // Validate booking time (must be in the future)\r\n        if (booking.getStartTime().isBefore(LocalDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Cannot book rooms in the past\");\r\n        }\r\n\r\n        if (booking.getEndTime().isBefore(booking.getStartTime())) {\r\n            throw new IllegalArgumentException(\"End time must be after start time\");\r\n        }\r\n\r\n        // Save the booking\r\n        Booking savedBooking = bookingRepository.save(booking);\r\n\r\n        // Update user points for gamification (5 points per booking)\r\n        userService.updateUserPoints(booking.getUser().getId(), 5);\r\n\r\n        // Send notification\r\n        notificationService.sendBookingConfirmation(savedBooking);\r\n\r\n        return savedBooking;\r\n    }\r\n\r\n    /**\r\n     * Cancel a booking\r\n     * @param bookingId Booking ID to cancel\r\n     * @param userId User requesting cancellation\r\n     * @return Updated booking\r\n     * @throws RuntimeException if booking or user not found, or permission denied\r\n     */\r\n    public Booking cancelBooking(Long bookingId, Long userId) {\r\n        Optional<Booking> bookingOpt = bookingRepository.findById(bookingId);\r\n\r\n        if (!bookingOpt.isPresent()) {\r\n            throw new RuntimeException(\"Booking not found\");\r\n        }\r\n\r\n        Booking booking = bookingOpt.get();\r\n\r\n        // Check if user owns this booking or is admin\r\n        User user = userService.findById(userId).orElseThrow(() ->\r\n                new RuntimeException(\"User not found\"));\r\n\r\n        if (!booking.getUser().getId().equals(userId) &&\r\n                !user.getRole().toString().equals(\"ADMIN\")) {\r\n            throw new RuntimeException(\"You don't have permission to cancel this booking\");\r\n        }\r\n\r\n        // Update booking status\r\n        booking.setStatus(BookingStatus.CANCELLED);\r\n        booking.setUpdatedAt(LocalDateTime.now());\r\n\r\n        Booking cancelledBooking = bookingRepository.save(booking);\r\n\r\n        // Send notification about cancellation\r\n        notificationService.sendCancellationNotification(cancelledBooking);\r\n\r\n        return cancelledBooking;\r\n    }\r\n\r\n    /**\r\n     * Get all bookings for a user\r\n     * @param user User to get bookings for\r\n     * @return List of user's bookings\r\n     */\r\n    public List<Booking> getUserBookings(User user) {\r\n        return bookingRepository.findByUser(user);\r\n    }\r\n\r\n    /**\r\n     * Get current bookings (happening now)\r\n     * @return List of current bookings\r\n     */\r\n    public List<Booking> getCurrentBookings() {\r\n        return bookingRepository.findCurrentBookings(LocalDateTime.now());\r\n    }\r\n\r\n    /**\r\n     * Get upcoming bookings for a room\r\n     * @param room Room to check\r\n     * @return List of upcoming bookings\r\n     */\r\n    public List<Booking> getUpcomingBookingsForRoom(Room room) {\r\n        return bookingRepository.findUpcomingBookingsForRoom(room, LocalDateTime.now());\r\n    }\r\n}",
      "info": {
        "size": 4303,
        "last_modified": "2025-06-09T12:10:03.7752295",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\service\\NotificationService.java",
      "content": "package com.smartroom.allocation.service;\r\n\r\nimport com.smartroom.allocation.entity.Booking;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.mail.SimpleMailMessage;\r\nimport org.springframework.mail.javamail.JavaMailSender;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class NotificationService {\r\n\r\n    @Autowired\r\n    private JavaMailSender mailSender;\r\n\r\n    /**\r\n     * Send booking confirmation email\r\n     * @param booking Confirmed booking\r\n     */\r\n    public void sendBookingConfirmation(Booking booking) {\r\n        try {\r\n            SimpleMailMessage message = new SimpleMailMessage();\r\n            message.setTo(booking.getUser().getEmail());\r\n            message.setSubject(\"Room Booking Confirmation - \" + booking.getRoom().getRoomNumber());\r\n            message.setText(String.format(\r\n                    \"Dear %s,\\n\\n\" +\r\n                            \"Your room booking has been confirmed:\\n\\n\" +\r\n                            \"Room: %s (%s)\\n\" +\r\n                            \"Date & Time: %s to %s\\n\" +\r\n                            \"Purpose: %s\\n\\n\" +\r\n                            \"Please arrive on time. If you need to cancel, please do so at least 30 minutes before the start time.\\n\\n\" +\r\n                            \"Best regards,\\n\" +\r\n                            \"Smart Room Allocation System\",\r\n                    booking.getUser().getFullName(),\r\n                    booking.getRoom().getRoomNumber(),\r\n                    booking.getRoom().getName(),\r\n                    booking.getStartTime().toString(),\r\n                    booking.getEndTime().toString(),\r\n                    booking.getPurpose()\r\n            ));\r\n\r\n            mailSender.send(message);\r\n        } catch (Exception e) {\r\n            // Log error but don't fail the booking process\r\n            System.err.println(\"Failed to send confirmation email: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send cancellation notification email\r\n     * @param booking Cancelled booking\r\n     */\r\n    public void sendCancellationNotification(Booking booking) {\r\n        try {\r\n            SimpleMailMessage message = new SimpleMailMessage();\r\n            message.setTo(booking.getUser().getEmail());\r\n            message.setSubject(\"Room Booking Cancelled - \" + booking.getRoom().getRoomNumber());\r\n            message.setText(String.format(\r\n                    \"Dear %s,\\n\\n\" +\r\n                            \"Your room booking has been cancelled:\\n\\n\" +\r\n                            \"Room: %s (%s)\\n\" +\r\n                            \"Date & Time: %s to %s\\n\" +\r\n                            \"Purpose: %s\\n\\n\" +\r\n                            \"The room is now available for other bookings.\\n\\n\" +\r\n                            \"Best regards,\\n\" +\r\n                            \"Smart Room Allocation System\",\r\n                    booking.getUser().getFullName(),\r\n                    booking.getRoom().getRoomNumber(),\r\n                    booking.getRoom().getName(),\r\n                    booking.getStartTime().toString(),\r\n                    booking.getEndTime().toString(),\r\n                    booking.getPurpose()\r\n            ));\r\n\r\n            mailSender.send(message);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Failed to send cancellation email: \" + e.getMessage());\r\n        }\r\n    }\r\n}",
      "info": {
        "size": 3379,
        "last_modified": "2025-06-09T12:10:03.7752295",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\service\\RoomService.java",
      "content": "package com.smartroom.allocation.service;\r\n\r\nimport com.smartroom.allocation.entity.Room;\r\nimport com.smartroom.allocation.entity.RoomStatus;\r\nimport com.smartroom.allocation.repository.RoomRepository;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Service\r\npublic class RoomService {\r\n\r\n    @Autowired\r\n    private RoomRepository roomRepository;\r\n\r\n    /**\r\n     * Get all active rooms\r\n     * @return List of active rooms\r\n     */\r\n    public List<Room> getAllActiveRooms() {\r\n        return roomRepository.findByActiveTrue();\r\n    }\r\n\r\n    /**\r\n     * Find room by ID\r\n     * @param id Room ID\r\n     * @return Room if found\r\n     */\r\n    public Optional<Room> findById(Long id) {\r\n        return roomRepository.findById(id);\r\n    }\r\n\r\n    /**\r\n     * Find room by room number\r\n     * @param roomNumber Room number to search for\r\n     * @return Room if found\r\n     */\r\n    public Optional<Room> findByRoomNumber(String roomNumber) {\r\n        return roomRepository.findByRoomNumber(roomNumber);\r\n    }\r\n\r\n    /**\r\n     * Find available rooms for a specific time period\r\n     * @param startTime Start time of booking\r\n     * @param endTime End time of booking\r\n     * @return List of available rooms\r\n     */\r\n    public List<Room> findAvailableRooms(LocalDateTime startTime, LocalDateTime endTime) {\r\n        return roomRepository.findAvailableRooms(startTime, endTime);\r\n    }\r\n\r\n    /**\r\n     * Find rooms with minimum capacity\r\n     * @param minCapacity Minimum capacity required\r\n     * @return List of rooms with sufficient capacity\r\n     */\r\n    public List<Room> findRoomsByMinCapacity(int minCapacity) {\r\n        return roomRepository.findByCapacityGreaterThanEqual(minCapacity);\r\n    }\r\n\r\n    /**\r\n     * Update room status\r\n     * @param roomId Room ID\r\n     * @param status New status\r\n     */\r\n    public void updateRoomStatus(Long roomId, RoomStatus status) {\r\n        Optional<Room> roomOpt = roomRepository.findById(roomId);\r\n        if (roomOpt.isPresent()) {\r\n            Room room = roomOpt.get();\r\n            room.setStatus(status);\r\n            roomRepository.save(room);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new room\r\n     * @param room Room to create\r\n     * @return Created room\r\n     */\r\n    public Room createRoom(Room room) {\r\n//        return roomRepository.save(room); // old implementation...did not check if unique iDs already exist\r\n        if (roomRepository.existsByRoomNumber(room.getRoomNumber())) {\r\n            throw new IllegalArgumentException(\"Room number already exists\");\r\n        }\r\n        room.setActive(true); // Ensure new rooms are active by default\r\n        return roomRepository.save(room);\r\n    }\r\n}",
      "info": {
        "size": 2815,
        "last_modified": "2025-06-09T12:10:03.7858349",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\service\\UserService.java",
      "content": "package com.smartroom.allocation.service;\r\n\r\nimport com.smartroom.allocation.entity.User;\r\nimport com.smartroom.allocation.entity.UserRole;\r\nimport com.smartroom.allocation.repository.BookingRepository;\r\nimport com.smartroom.allocation.repository.UserRepository;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Service\r\npublic class UserService {\r\n\r\n    @Autowired\r\n    private UserRepository userRepository;\r\n\r\n    @Autowired\r\n    private PasswordEncoder passwordEncoder;\r\n\r\n    @Autowired\r\n    private BookingRepository bookingRepository;\r\n\r\n    /**\r\n     * Register a new user\r\n     * @param user User to register\r\n     * @return Registered user\r\n     */\r\n    public User registerUser(User user) {\r\n        // Check if username or email already exists\r\n        if (userRepository.existsByUsername(user.getUsername())) {\r\n            throw new RuntimeException(\"Username already exists\");\r\n        }\r\n        if (userRepository.existsByEmail(user.getEmail())) {\r\n            throw new RuntimeException(\"Email already exists\");\r\n        }\r\n\r\n        // Encode password before saving\r\n        user.setPassword(passwordEncoder.encode(user.getPassword()));\r\n\r\n        return userRepository.save(user);\r\n    }\r\n\r\n    /*Get all users available\r\n    * for admins only*/\r\n    public List<User> getAllUsers() {\r\n//        return userRepository.findAll();\r\n        List<User> users = userRepository.findAll();\r\n        for (User user : users) {\r\n            int count = bookingRepository.countByUser(user);\r\n            user.setTotalBookings(count); // Ensure this setter exists\r\n        }\r\n        return users;\r\n    }\r\n\r\n    /**\r\n     * Find user by username (for authentication)\r\n     * @param username Username to search for\r\n     * @return User if found\r\n     */\r\n    public Optional<User> findByUsername(String username) {\r\n        return userRepository.findByUsername(username);\r\n    }\r\n\r\n    /**\r\n     * Get all active users\r\n     * @return List of active users\r\n     */\r\n    public List<User> getAllActiveUsers() {\r\n        return userRepository.findByActiveTrue();\r\n    }\r\n\r\n    /**\r\n     * Get users by role\r\n     * @param role User role to filter by\r\n     * @return List of users with specified role\r\n     */\r\n    public List<User> getUsersByRole(UserRole role) {\r\n        return userRepository.findByRole(role);\r\n    }\r\n\r\n    /**\r\n     * Update user points (for gamification)\r\n     * @param userId User ID\r\n     * @param points Points to add\r\n     */\r\n    public void updateUserPoints(Long userId, int points) {\r\n        Optional<User> userOpt = userRepository.findById(userId);\r\n        if (userOpt.isPresent()) {\r\n            User user = userOpt.get();\r\n            user.setPoints(user.getPoints() + points);\r\n            userRepository.save(user);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get leaderboard (top users by points)\r\n     * @return List of top users\r\n     */\r\n    public List<User> getLeaderboard() {\r\n        return userRepository.findTopUsersByPoints();\r\n    }\r\n\r\n    /**\r\n     * Find user by ID\r\n     * @param id User ID\r\n     * @return User if found\r\n     */\r\n    public Optional<User> findById(Long id) {\r\n        return userRepository.findById(id);\r\n    }\r\n\r\n    public Optional<User> updateUserById(Long id, User userUpdate) {\r\n        return userRepository.findById(id).map(user -> {\r\n            user.setDepartment(userUpdate.getDepartment());\r\n            user.setFullName(userUpdate.getFullName());\r\n            user.setActive(userUpdate.isActive());\r\n            user.setRole(userUpdate.getRole());\r\n            user.setPoints(userUpdate.getPoints());\r\n            user.setUsageStreak(userUpdate.getUsageStreak());\r\n            return userRepository.save(user);\r\n        });\r\n    }\r\n\r\n    public boolean deleteUserById(Long id) {\r\n        if (userRepository.existsById(id)) {\r\n            userRepository.deleteById(id);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}",
      "info": {
        "size": 4106,
        "last_modified": "2025-06-09T12:10:03.7858349",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\smartroom\\allocation\\SmartRoomAllocationApplication.java",
      "content": "package com.smartroom.allocation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\n@SpringBootApplication\n@EnableScheduling\npublic class SmartRoomAllocationApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SmartRoomAllocationApplication.class, args);\n\t}\n\n}\n",
      "info": {
        "size": 428,
        "last_modified": "2025-06-09T12:10:03.7858349",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\resources\\application.properties",
      "content": "spring.application.name=smart-room-allocation\n# Database Configuration\nspring.datasource.url=jdbc:postgresql://localhost:5432/smart_room_db\nspring.datasource.username=postgres\nspring.datasource.password=root\nspring.datasource.driver-class-name=org.postgresql.Driver\n\n# JPA Configuration\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\nspring.jpa.properties.hibernate.format_sql=true\n\n\n# Server Configuration\nserver.port=8080\n\n# Email Configuration (for notifications)\nspring.mail.host=smtp.gmail.com\nspring.mail.port=587\nspring.mail.username=jessecrks@gmail.com\nspring.mail.password=iixf inky qkth wgul\nspring.mail.properties.mail.smtp.auth=true\nspring.mail.properties.mail.smtp.starttls.enable=true\n\n#Security Debugging\nlogging.level.org.springframework.security=DEBUG\n# JWT Configuration\njwt.secret=Hle7WC9OS5WgTCR7MKAXyksDP9bMuPTHYiB1O7Ery/8=\njwt.expiration=86400000",
      "info": {
        "size": 963,
        "last_modified": "2025-06-09T12:10:03.8055908",
        "mime_type": "text/x-java-properties",
        "extension": ".properties"
      }
    },
    {
      "path": "test\\java\\com\\smartroom\\allocation\\SmartRoomAllocationApplicationTests.java",
      "content": "package com.smartroom.allocation;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass SmartRoomAllocationApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {\n\t}\n\n}\n",
      "info": {
        "size": 229,
        "last_modified": "2025-06-09T12:10:03.8159301",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    }
  ]
}